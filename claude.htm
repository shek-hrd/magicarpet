<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Streaming Protocol Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        
        .control-group h3 {
            margin-bottom: 15px;
            color: #ffd700;
        }
        
        .file-input {
            width: 100%;
            padding: 10px;
            border: 2px dashed #ffd700;
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
            color: white;
            cursor: pointer;
        }
        
        .btn {
            background: linear-gradient(135deg, #ffd700, #ffb300);
            color: #1e3c72;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255,215,0,0.3);
        }
        
        .slider-group {
            margin: 10px 0;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        .slider {
            width: 100%;
            margin: 10px 0;
        }
        
        .chart-container {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }
        
        .canvas-container {
            position: relative;
            height: 500px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            overflow: hidden;
        }
        
        #priceCanvas {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(30,60,114,0.8), rgba(42,82,152,0.8));
            cursor: crosshair;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-card .value {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffb300);
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .log {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            margin-top: 20px;
        }
        
        .download-links {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }
        
        .download-links a {
            color: #ffd700;
            text-decoration: none;
            padding: 8px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }
        
        .download-links a:hover {
            background: rgba(255,215,0,0.2);
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Cryptocurrency Streaming Protocol Demo</h1>
            <p>Advanced curve-based streaming visualization with derivative encoding</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>üìà Data Source</h3>
                <input type="file" id="fileInput" class="file-input" accept=".csv,.json" 
                       title="Upload your own BTC price data (CSV/JSON)">
                <div class="download-links">
                    <a href="#" onclick="downloadSampleData('kaggle')">üìä Kaggle BTC Data</a>
                    <a href="#" onclick="downloadSampleData('coinmarketcap')">üìà CoinMarketCap</a>
                    <a href="#" onclick="downloadSampleData('cryptodata')">üíæ CryptoDataDownload</a>
                </div>
                <button class="btn" onclick="generateSampleData()">Generate Sample Data</button>
                <button class="btn" onclick="startStreaming()">üé¨ Start Streaming</button>
            </div>
            
            <div class="control-group">
                <h3>‚öôÔ∏è Stream Settings</h3>
                <div class="slider-group">
                    <label>Detail Level: <span id="detailValue">5</span></label>
                    <input type="range" class="slider" id="detailSlider" min="1" max="10" value="5">
                </div>
                <div class="slider-group">
                    <label>Stream Speed: <span id="speedValue">50</span>ms</label>
                    <input type="range" class="slider" id="speedSlider" min="10" max="500" value="50">
                </div>
                <div class="slider-group">
                    <label>Curve Smoothness: <span id="smoothValue">0.5</span></label>
                    <input type="range" class="slider" id="smoothSlider" min="0" max="1" step="0.1" value="0.5">
                </div>
            </div>
            
            <div class="control-group">
                <h3>üìä View Controls</h3>
                <div class="slider-group">
                    <label>Zoom Level: <span id="zoomValue">1x</span></label>
                    <input type="range" class="slider" id="zoomSlider" min="0.1" max="10" step="0.1" value="1">
                </div>
                <div class="slider-group">
                    <label>Time Range: <span id="rangeValue">All</span></label>
                    <input type="range" class="slider" id="rangeSlider" min="0" max="100" value="100">
                </div>
                <button class="btn" onclick="resetView()">üîÑ Reset View</button>
                <button class="btn" onclick="exportCurve()">üíæ Export Curve</button>
            </div>
        </div>
        
        <div class="chart-container">
            <h3>üíπ Real-time Price Curve Visualization</h3>
            <div class="canvas-container">
                <canvas id="priceCanvas"></canvas>
            </div>
            <div class="progress">
                <div class="progress-bar" id="streamProgress"></div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="value" id="currentPrice">$0</div>
                <div>Current Price</div>
            </div>
            <div class="stat-card">
                <div class="value" id="dataPoints">0</div>
                <div>Data Points Streamed</div>
            </div>
            <div class="stat-card">
                <div class="value" id="curvePrecision">0.0%</div>
                <div>Curve Precision</div>
            </div>
            <div class="stat-card">
                <div class="value" id="streamRate">0</div>
                <div>Stream Rate (pts/s)</div>
            </div>
        </div>
        
        <div class="log" id="streamLog"></div>
    </div>

    <script>
        class CryptoStreamingProtocol {
            constructor() {
                this.canvas = document.getElementById('priceCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.priceData = [];
                this.curvePoints = [];
                this.derivatives = [];
                this.streamingActive = false;
                this.streamIndex = 0;
                this.zoomLevel = 1;
                this.panX = 0;
                this.panY = 0;
                this.detailLevel = 5;
                this.smoothness = 0.5;
                
                this.initializeCanvas();
                this.setupEventListeners();
                this.generateSampleData();
            }
            
            initializeCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                    this.zoomLevel *= zoomFactor;
                    this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
                    document.getElementById('zoomValue').textContent = this.zoomLevel.toFixed(1) + 'x';
                    document.getElementById('zoomSlider').value = this.zoomLevel;
                    this.redrawCanvas();
                });
                
                let isDragging = false;
                let lastX, lastY;
                
                this.canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - lastX;
                        const deltaY = e.clientY - lastY;
                        this.panX += deltaX / this.zoomLevel;
                        this.panY += deltaY / this.zoomLevel;
                        lastX = e.clientX;
                        lastY = e.clientY;
                        this.redrawCanvas();
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                this.redrawCanvas();
            }
            
            setupEventListeners() {
                document.getElementById('detailSlider').oninput = (e) => {
                    this.detailLevel = parseInt(e.target.value);
                    document.getElementById('detailValue').textContent = this.detailLevel;
                    this.recalculateDerivatives();
                };
                
                document.getElementById('speedSlider').oninput = (e) => {
                    document.getElementById('speedValue').textContent = e.target.value + 'ms';
                };
                
                document.getElementById('smoothSlider').oninput = (e) => {
                    this.smoothness = parseFloat(e.target.value);
                    document.getElementById('smoothValue').textContent = this.smoothness;
                    this.recalculateDerivatives();
                };
                
                document.getElementById('zoomSlider').oninput = (e) => {
                    this.zoomLevel = parseFloat(e.target.value);
                    document.getElementById('zoomValue').textContent = this.zoomLevel.toFixed(1) + 'x';
                    this.redrawCanvas();
                };
                
                document.getElementById('rangeSlider').oninput = (e) => {
                    const percentage = parseInt(e.target.value);
                    document.getElementById('rangeValue').textContent = percentage === 100 ? 'All' : percentage + '%';
                    this.redrawCanvas();
                };
                
                document.getElementById('fileInput').onchange = (e) => {
                    this.loadFile(e.target.files[0]);
                };
            }
            
            generateSampleData() {
                this.priceData = [];
                const startPrice = 30000;
                const days = 365 * 2; // 2 years of data
                const pointsPerDay = 24; // hourly data
                
                let currentPrice = startPrice;
                const startDate = new Date('2022-01-01');
                
                for (let i = 0; i < days * pointsPerDay; i++) {
                    const date = new Date(startDate.getTime() + (i * 60 * 60 * 1000));
                    
                    // Simulate realistic price movements with trends and volatility
                    const trendFactor = Math.sin(i / (days * pointsPerDay) * Math.PI * 2) * 0.1;
                    const volatility = (Math.random() - 0.5) * 0.02;
                    const dailyCycle = Math.sin(i / pointsPerDay * Math.PI * 2) * 0.005;
                    
                    currentPrice *= (1 + trendFactor + volatility + dailyCycle);
                    currentPrice = Math.max(1000, Math.min(100000, currentPrice)); // Clamp price
                    
                    this.priceData.push({
                        timestamp: date.getTime(),
                        price: currentPrice,
                        volume: Math.random() * 1000000000
                    });
                }
                
                this.log('Generated ' + this.priceData.length + ' sample data points');
                this.processDataIntoCurves();
                this.updateStats();
            }
            
            processDataIntoCurves() {
                if (this.priceData.length < 3) return;
                
                this.curvePoints = [];
                this.derivatives = [];
                
                // Convert timestamps to x coordinates and prices to y coordinates
                const timeRange = this.priceData[this.priceData.length - 1].timestamp - this.priceData[0].timestamp;
                const priceMin = Math.min(...this.priceData.map(d => d.price));
                const priceMax = Math.max(...this.priceData.map(d => d.price));
                const priceRange = priceMax - priceMin;
                
                // Create normalized curve points
                for (let i = 0; i < this.priceData.length; i++) {
                    const data = this.priceData[i];
                    const x = (data.timestamp - this.priceData[0].timestamp) / timeRange;
                    const y = (data.price - priceMin) / priceRange;
                    
                    this.curvePoints.push({ x, y, price: data.price, timestamp: data.timestamp });
                }
                
                // Calculate derivatives for curve representation
                this.calculateDerivatives();
                this.optimizeStreamingOrder();
                
                this.log('Processed data into ' + this.curvePoints.length + ' curve points with ' + this.derivatives.length + ' derivatives');
            }
            
            calculateDerivatives() {
                this.derivatives = [];
                
                for (let i = 1; i < this.curvePoints.length - 1; i++) {
                    const prev = this.curvePoints[i - 1];
                    const curr = this.curvePoints[i];
                    const next = this.curvePoints[i + 1];
                    
                    // Calculate first and second derivatives
                    const dx1 = curr.x - prev.x;
                    const dy1 = curr.y - prev.y;
                    const dx2 = next.x - curr.x;
                    const dy2 = next.y - curr.y;
                    
                    const firstDeriv = dy1 / dx1;
                    const secondDeriv = (dy2 / dx2 - dy1 / dx1) / ((dx1 + dx2) / 2);
                    
                    // Calculate curvature
                    const curvature = Math.abs(secondDeriv) / Math.pow(1 + firstDeriv * firstDeriv, 1.5);
                    
                    this.derivatives.push({
                        index: i,
                        point: curr,
                        firstDeriv,
                        secondDeriv,
                        curvature,
                        importance: curvature * (1 + Math.abs(firstDeriv)) // Higher importance for areas with high curvature and slope
                    });
                }
            }
            
            optimizeStreamingOrder() {
                // Sort derivatives by importance (high curvature areas first)
                this.derivatives.sort((a, b) => b.importance - a.importance);
                
                // Create optimized streaming order
                this.streamOrder = [];
                
                // Add most important points first (high curvature/volatility areas)
                const importantPoints = this.derivatives.slice(0, this.derivatives.length / 4);
                importantPoints.forEach(d => this.streamOrder.push(d.index));
                
                // Add medium importance points
                const mediumPoints = this.derivatives.slice(this.derivatives.length / 4, this.derivatives.length / 2);
                mediumPoints.forEach(d => this.streamOrder.push(d.index));
                
                // Add remaining points for fine detail
                const remainingPoints = this.derivatives.slice(this.derivatives.length / 2);
                remainingPoints.forEach(d => this.streamOrder.push(d.index));
                
                this.log('Optimized streaming order: ' + this.streamOrder.length + ' points prioritized by importance');
            }
            
            recalculateDerivatives() {
                if (this.curvePoints.length > 0) {
                    this.calculateDerivatives();
                    this.optimizeStreamingOrder();
                    this.redrawCanvas();
                }
            }
            
            startStreaming() {
                if (this.streamingActive) {
                    this.streamingActive = false;
                    this.log('Streaming stopped');
                    return;
                }
                
                this.streamingActive = true;
                this.streamIndex = 0;
                this.streamedPoints = new Set();
                
                this.log('Starting streaming protocol...');
                this.streamData();
            }
            
            streamData() {
                if (!this.streamingActive || this.streamIndex >= this.streamOrder.length) {
                    this.streamingActive = false;
                    this.log('Streaming completed');
                    return;
                }
                
                const speed = parseInt(document.getElementById('speedSlider').value);
                const batchSize = Math.max(1, Math.floor(this.detailLevel / 2));
                
                // Stream a batch of points
                for (let i = 0; i < batchSize && this.streamIndex < this.streamOrder.length; i++) {
                    const pointIndex = this.streamOrder[this.streamIndex];
                    this.streamedPoints.add(pointIndex);
                    this.streamIndex++;
                }
                
                // Update visualization
                this.updateStats();
                this.redrawCanvas();
                
                // Continue streaming
                setTimeout(() => this.streamData(), speed);
            }
            
            updateStats() {
                const streamedCount = this.streamedPoints.size;
                const totalPoints = this.curvePoints.length;
                const progress = (streamedCount / totalPoints) * 100;
                
                if (streamedCount > 0) {
                    const currentIndex = Math.max(...this.streamedPoints);
                    const currentPoint = this.curvePoints[currentIndex];
                    document.getElementById('currentPrice').textContent = '$' + (currentPoint?.price?.toLocaleString() || '0');
                }
                
                document.getElementById('dataPoints').textContent = streamedCount.toLocaleString();
                document.getElementById('curvePrecision').textContent = progress.toFixed(1) + '%';
                document.getElementById('streamRate').textContent = Math.floor(streamedCount / Math.max(1, (Date.now() - this.streamStartTime) / 1000));
                
                document.getElementById('streamProgress').style.width = progress + '%';
            }
            
            redrawCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                
                this.ctx.clearRect(0, 0, width, height);
                
                // Draw grid
                this.drawGrid(width, height);
                
                // Draw price curve
                this.drawPriceCurve(width, height);
                
                // Draw streamed points
                this.drawStreamedPoints(width, height);
            }
            
            drawGrid(width, height) {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                const offsetX = this.panX % gridSize;
                const offsetY = this.panY % gridSize;
                
                this.ctx.beginPath();
                for (let x = offsetX; x < width; x += gridSize) {
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, height);
                }
                for (let y = offsetY; y < height; y += gridSize) {
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(width, y);
                }
                this.ctx.stroke();
            }
            
            drawPriceCurve(width, height) {
                if (this.curvePoints.length < 2) return;
                
                const margin = 50;
                const chartWidth = width - 2 * margin;
                const chartHeight = height - 2 * margin;
                
                // Base curve (low detail)
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                
                const step = Math.max(1, Math.floor(this.curvePoints.length / 1000)); // Subsample for base curve
                for (let i = 0; i < this.curvePoints.length; i += step) {
                    const point = this.curvePoints[i];
                    const x = margin + (point.x * chartWidth * this.zoomLevel) + this.panX;
                    const y = margin + ((1 - point.y) * chartHeight * this.zoomLevel) + this.panY;
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
            }
            
            drawStreamedPoints(width, height) {
                if (this.streamedPoints.size === 0) return;
                
                const margin = 50;
                const chartWidth = width - 2 * margin;
                const chartHeight = height - 2 * margin;
                
                // High-detail curve from streamed points
                const sortedIndices = Array.from(this.streamedPoints).sort((a, b) => a - b);
                
                // Draw smooth curve through streamed points
                this.ctx.strokeStyle = '#ffd700';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                for (let i = 0; i < sortedIndices.length; i++) {
                    const pointIndex = sortedIndices[i];
                    const point = this.curvePoints[pointIndex];
                    const x = margin + (point.x * chartWidth * this.zoomLevel) + this.panX;
                    const y = margin + ((1 - point.y) * chartHeight * this.zoomLevel) + this.panY;
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        // Use smooth curves between points
                        const prevIndex = sortedIndices[i - 1];
                        const prevPoint = this.curvePoints[prevIndex];
                        const prevX = margin + (prevPoint.x * chartWidth * this.zoomLevel) + this.panX;
                        const prevY = margin + ((1 - prevPoint.y) * chartHeight * this.zoomLevel) + this.panY;
                        
                        const cpX = (prevX + x) / 2;
                        const cpY = prevY + (y - prevY) * this.smoothness;
                        
                        this.ctx.quadraticCurveTo(cpX, cpY, x, y);
                    }
                }
                this.ctx.stroke();
                
                // Draw importance indicators
                this.ctx.fillStyle = '#ff6b6b';
                sortedIndices.forEach(index => {
                    const derivative = this.derivatives.find(d => d.index === index);
                    if (derivative && derivative.importance > this.detailLevel / 10) {
                        const point = this.curvePoints[index];
                        const x = margin + (point.x * chartWidth * this.zoomLevel) + this.panX;
                        const y = margin + ((1 - point.y) * chartHeight * this.zoomLevel) + this.panY;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        this.ctx.fill();
                    }
                });
            }
            
            loadFile(file) {
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        let data;
                        
                        if (file.name.endsWith('.json')) {
                            data = JSON.parse(content);
                        } else if (file.name.endsWith('.csv')) {
                            data = this.parseCSV(content);
                        }
                        
                        if (data) {
                            this.priceData = data;
                            this.processDataIntoCurves();
                            this.log('Loaded ' + data.length + ' data points from ' + file.name);
                        }
                    } catch (error) {
                        this.log('Error loading file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
            
            parseCSV(content) {
                const lines = content.split('\n');
                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                const data = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    if (values.length === headers.length) {
                        const entry = {};
                        headers.forEach((header, index) => {
                            const value = values[index].trim();
                            if (header.includes('price') || header.includes('close')) {
                                entry.price = parseFloat(value);
                            } else if (header.includes('time') || header.includes('date')) {
                                entry.timestamp = new Date(value).getTime();
                            } else if (header.includes('volume')) {
                                entry.volume = parseFloat(value);
                            }
                        });
                        
                        if (entry.price && entry.timestamp) {
                            data.push(entry);
                        }
                    }
                }
                
                return data.sort((a, b) => a.timestamp - b.timestamp);
            }
            
            log(message) {
                const logElement = document.getElementById('streamLog');
                const timestamp = new Date().toLocaleTimeString();
                logElement.innerHTML += `[${timestamp}] ${message}\n`;
                logElement.scrollTop = logElement.scrollHeight;
            }
            
            resetView() {
                this.zoomLevel = 1;
                this.panX = 0;
                this.panY = 0;
                document.getElementById('zoomSlider').value = 1;
                document.getElementById('zoomValue').textContent = '1.0x';
                document.getElementById('rangeSlider').value = 100;
                document.getElementById('rangeValue').textContent = 'All';
                this.redrawCanvas();
                this.log('View reset to default');
            }
            
            exportCurve() {
                if (this.derivatives.length === 0) {
                    this.log('No curve data to export');
                    return;
                }
                
                const exportData = {
                    curvePoints: this.curvePoints,
                    derivatives: this.derivatives,
                    streamOrder: this.streamOrder,
                    settings: {
                        detailLevel: this.detailLevel,
                        smoothness: this.smoothness,
                        zoomLevel: this.zoomLevel
                    }
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'crypto-curve-data.json';
                a.click();
                URL.revokeObjectURL(url);
                
                this.log('Curve data exported');
            }
        }
        
        // Global functions
        function downloadSampleData(source) {
            const urls = {
                kaggle: 'https://www.kaggle.com/datasets/mczielinski/bitcoin-historical-data',
                coinmarketcap: 'https://coinmarketcap.com/currencies/bitcoin/historical-data/',
                cryptodata: 'https://www.cryptodatadownload.com/data/binance/'
            };
            
            window.open(urls[source], '_blank');
            protocol.log('Opening ' + source + ' data source...');
        }
        
        function generateSampleData() {
            protocol.generateSampleData();
        }
        
        function startStreaming() {
            protocol.streamStartTime = Date.now();
            protocol.startStreaming();
        }
        
        function resetView() {
            protocol.resetView();
        }
        
        function exportCurve() {
            protocol.exportCurve();
        }
        
        // Initialize the protocol
        const protocol = new CryptoStreamingProtocol();
    </script>
</body>
</html>