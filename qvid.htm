<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üåå Universal Curve Streaming Protocol</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      padding: 0;
      background: #0a0a12;
      color: #e0e0ff;
      display: flex;
      min-height: 100vh;
    }
    .split {
      display: flex;
      width: 100%;
      height: 100vh;
    }
    .panel {
      width: 50%;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
    }
    .server {
      background: #0d0d1a;
      border-right: 2px solid #333;
    }
    .client {
      background: #0a0a14;
    }
    h1, h2 {
      text-align: center;
      background: linear-gradient(90deg, #00ffff, #ff00ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-top: 0;
    }
    .server h1 { background: linear-gradient(90deg, #ff9a00, #ff4a00); }
    .client h1 { background: linear-gradient(90deg, #00ffaa, #00aaff); }

    button, input, select {
      padding: 10px 15px;
      margin: 5px 0;
      border: none;
      border-radius: 6px;
      background: #2a2a4a;
      color: white;
      cursor: pointer;
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
    }
    input[type="text"], input[type="file"] {
      color: #ccc;
    }
    .progress {
      width: 100%;
      height: 10px;
      background: #1a1a30;
      border-radius: 5px;
      margin: 10px 0;
      overflow: hidden;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #00ffaa, #00aaff);
      width: 0%;
      transition: width 0.3s ease;
    }
    #chart {
      width: 100%;
      height: 250px;
      background: #070710;
      border-radius: 8px;
      margin: 15px 0;
      position: relative;
    }
    svg {
      display: block;
      width: 100%;
      height: 100%;
    }
    .log {
      background: #0c0c16;
      padding: 10px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
      height: 150px;
      overflow-y: auto;
      margin-top: 10px;
    }
    .loader {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00ffaa;
      font-size: 18px;
    }
    .media-container {
      width: 100%;
      height: 250px;
      background: #070710;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 15px 0;
      color: #aaa;
    }
    video, audio {
      max-width: 100%;
      max-height: 100%;
    }
  </style>
</head>
<body>
  <div class="split">
    <!-- SERVER SIDE PANEL -->
    <div class="panel server">
      <h1>‚öôÔ∏è SERVER EMULATOR</h1>
      <h2>üìà Graph (BTC Price)</h2>
      <input type="file" id="graphFile" accept=".csv" />
      <div class="progress"><div class="progress-bar" id="graphProgress"></div></div>
      <button id="loadGraphBtn">üì• Load samplebtc.csv</button>

      <h2>üéß Audio Stream</h2>
      <input type="text" id="audioUrl" placeholder="YouTube URL or direct MP3/WAV link" />
      <button id="loadAudioBtn">üì• Load Highest Quality Audio</button>
      <div class="progress"><div class="progress-bar" id="audioProgress"></div></div>

      <h2>üé• Video Stream</h2>
      <input type="text" id="videoUrl" placeholder="YouTube URL or direct MP4 link" />
      <button id="loadVideoBtn">üì• Load Highest Quality Video</button>
      <div class="progress"><div class="progress-bar" id="videoProgress"></div></div>

      <h2>üì§ Streaming Control</h2>
      <button id="startStreamBtn" disabled>‚ñ∂Ô∏è Start Streaming All</button>
      <button id="resetStreamBtn">üîÅ Reset Stream</button>

      <div class="log" id="serverLog">[Server Log] Waiting for data...</div>
    </div>

    <!-- CLIENT SIDE PANEL -->
    <div class="panel client">
      <h1>üì° CLIENT EMULATOR</h1>
      <h2>üìä Graph Stream</h2>
      <div id="chart">
        <div class="loader">Awaiting stream...</div>
        <svg id="svg"></svg>
      </div>

      <h2>üîä Audio Stream</h2>
      <div class="media-container" id="audioContainer">
        No audio stream yet.
      </div>

      <h2>üé¨ Video Stream</h2>
      <div class="media-container" id="videoContainer">
        No video stream yet.
      </div>

      <div class="log" id="clientLog">[Client Log] Ready to receive...</div>
    </div>
  </div>

  <script>
    // ======================
    // SERVER-SIDE LOGIC (ENCODING / CHUNKING / SORTING)
    // ======================
    class Server {
      constructor() {
        this.graphData = null;
        this.audioData = null;
        this.videoData = null;
        this.derivativeVectors = [];
        this.streamChunks = [];
        this.chunkIndex = 0;
        this.onChunkReady = null;
        this.onComplete = null;
      }

      // --- GRAPH ---
      async loadGraphData(fileOrPath, progressCallback) {
        this.log("Loading graph data...");
        let text;
        if (typeof fileOrPath === 'string') {
          // Load from path
          const response = await fetch(fileOrPath);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const reader = response.body.getReader();
          const contentLength = +response.headers.get('Content-Length') || 1;
          let receivedLength = 0;
          let chunks = [];
          while(true) {
            const {done, value} = await reader.read();
            if (done) break;
            chunks.push(value);
            receivedLength += value.length;
            if (progressCallback) progressCallback(receivedLength / contentLength);
          }
          let uint8Array = new Uint8Array(receivedLength);
          let position = 0;
          for (let chunk of chunks) {
            uint8Array.set(chunk, position);
            position += chunk.length;
          }
          text = new TextDecoder().decode(uint8Array);
        } else {
          // Load from File object
          text = await fileOrPath.text();
          if (progressCallback) progressCallback(1);
        }
        this.graphData = this.parseCSV(text);
        this.log(`‚úÖ Graph data loaded: ${this.graphData.length} points.`);
      }

      parseCSV(text) {
        const lines = text.trim().split('\n');
        const result = [];
        for (let line of lines) {
          line = line.trim();
          if (!line || line.startsWith('#')) continue;
          const parts = line.split(/[,;\t]/);
          if (parts.length < 2) continue;
          let timestamp = parseFloat(parts[0]);
          let price = parseFloat(parts[1]);
          if (timestamp && timestamp < 1e12) timestamp *= 1000;
          if (!isNaN(timestamp) && !isNaN(price)) {
            result.push([timestamp, price]);
          }
        }
        return result.sort((a, b) => a[0] - b[0]);
      }

      encodeGraphToVectors() {
        if (!this.graphData || this.graphData.length < 3) return;
        const vectors = [];
        for (let i = 1; i < this.graphData.length - 1; i++) {
          const [t0, p0] = this.graphData[i-1];
          const [t1, p1] = this.graphData[i];
          const [t2, p2] = this.graphData[i+1];
          const dt = (t2 - t0) / 2;
          const dp = (p2 - p0) / 2;
          if (dt === 0) continue;
          const len = Math.sqrt(dt*dt + dp*dp);
          const dx = dt / len;
          const dy = dp / len;
          vectors.push({
            type: 'graph',
            x: t1,
            y: p1,
            dx, dy, mag: len, t: t1,
            curvature: Math.abs(dp / dt)
          });
        }
        this.derivativeVectors = this.sortByImportance(vectors);
        this.log(`üî¢ Encoded ${vectors.length} graph vectors.`);
      }

      // --- AUDIO ---
      async loadAudioData(url, progressCallback) {
        this.log(`Loading audio from: ${url}`);
        // In real app: use youtube-dl or backend to get highest quality audio
        // For demo: assume direct link to MP3/WAV
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const contentLength = +response.headers.get('Content-Length') || 1;
        const reader = response.body.getReader();
        let receivedLength = 0;
        let chunks = [];
        while(true) {
          const {done, value} = await reader.read();
          if (done) break;
          chunks.push(value);
          receivedLength += value.length;
          if (progressCallback) progressCallback(receivedLength / contentLength);
        }
        let blob = new Blob(chunks, {type: 'audio/mpeg'});
        this.audioData = URL.createObjectURL(blob);
        this.log(`üéµ Audio loaded: ${Math.round(receivedLength/1024)} KB`);
      }

      // --- VIDEO ---
      async loadVideoData(url, progressCallback) {
        this.log(`Loading video from: ${url}`);
        // In real app: use youtube-dl or backend to get 4K/Highest quality
        // For demo: assume direct MP4 link
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const contentLength = +response.headers.get('Content-Length') || 1;
        const reader = response.body.getReader();
        let receivedLength = 0;
        let chunks = [];
        while(true) {
          const {done, value} = await reader.read();
          if (done) break;
          chunks.push(value);
          receivedLength += value.length;
          if (progressCallback) progressCallback(receivedLength / contentLength);
        }
        let blob = new Blob(chunks, {type: 'video/mp4'});
        this.videoData = URL.createObjectURL(blob);
        this.log(`üé¨ Video loaded: ${Math.round(receivedLength/1024/1024)} MB`);
      }

      // --- STREAM PREP ---
      prepareStream() {
        this.streamChunks = [];
        // Interleave chunks from all sources for demo
        if (this.derivativeVectors.length) {
          for (let i = 0; i < this.derivativeVectors.length; i += 10) {
            this.streamChunks.push({
              type: 'graph',
              data: this.derivativeVectors.slice(i, i+10)
            });
          }
        }
        if (this.audioData) {
          this.streamChunks.push({ type: 'audio', data: this.audioData });
        }
        if (this.videoData) {
          this.streamChunks.push({ type: 'video', data: this.videoData });
        }
        this.chunkIndex = 0;
        this.log(`üì¶ Stream prepared: ${this.streamChunks.length} chunks.`);
      }

      // --- STREAMING ---
      startStreaming(interval = 200) {
        if (this.streamInterval) clearInterval(this.streamInterval);
        this.chunkIndex = 0;
        this.streamInterval = setInterval(() => {
          if (this.chunkIndex >= this.streamChunks.length) {
            clearInterval(this.streamInterval);
            this.log("‚úÖ Streaming completed.");
            if (this.onComplete) this.onComplete();
            return;
          }
          const chunk = this.streamChunks[this.chunkIndex];
          if (this.onChunkReady) this.onChunkReady(chunk);
          this.chunkIndex++;
          this.log(`üì§ Sent chunk ${this.chunkIndex}/${this.streamChunks.length} (${chunk.type})`);
        }, interval);
      }

      sortByImportance(vectors) {
        return [...vectors].sort((a, b) => {
          const timeWeight = 0.7;
          const curveWeight = 0.3;
          const now = Date.now();
          const aRecency = now - a.t;
          const bRecency = now - b.t;
          const aScore = timeWeight * (1 / (aRecency + 1)) + curveWeight * a.curvature;
          const bScore = timeWeight * (1 / (bRecency + 1)) + curveWeight * b.curvature;
          return bScore - aScore;
        });
      }

      log(msg) {
        const logDiv = document.getElementById('serverLog');
        logDiv.textContent += `\n[SERVER] ${msg}`;
        logDiv.scrollTop = logDiv.scrollHeight;
      }
    }

    // ======================
    // CLIENT-SIDE LOGIC (RECEIVING / RENDERING)
    // ======================
    class Client {
      constructor() {
        this.graphVectors = [];
        this.audioUrl = null;
        this.videoUrl = null;
      }

      receiveChunk(chunk) {
        switch(chunk.type) {
          case 'graph':
            this.graphVectors.push(...chunk.data);
            this.renderGraph();
            document.getElementById('clientLog').textContent += `\n[CLIENT] üìä Received ${chunk.data.length} graph vectors. Total: ${this.graphVectors.length}`;
            break;
          case 'audio':
            this.audioUrl = chunk.data;
            this.renderAudio();
            document.getElementById('clientLog').textContent += `\n[CLIENT] üîä Audio ready to play.`;
            break;
          case 'video':
            this.videoUrl = chunk.data;
            this.renderVideo();
            document.getElementById('clientLog').textContent += `\n[CLIENT] üé¨ Video ready to play.`;
            break;
        }
        document.getElementById('clientLog').scrollTop = document.getElementById('clientLog').scrollHeight;
      }

      renderGraph() {
        const vectors = this.graphVectors;
        if (vectors.length < 2) return;

        const svg = document.getElementById('svg');
        const times = vectors.map(v => v.x);
        const prices = vectors.map(v => v.y);
        const tMin = Math.min(...times);
        const tMax = Math.max(...times);
        const pMin = Math.min(...prices);
        const pMax = Math.max(...prices);
        const width = svg.clientWidth;
        const height = svg.clientHeight;

        const x = t => ((t - tMin) / (tMax - tMin)) * width;
        const y = p => height - ((p - pMin) / (pMax - pMin)) * height;

        let pathData = `M ${x(vectors[0].x)} ${y(vectors[0].y)}`;
        for (let i = 0; i < vectors.length - 1; i++) {
          const p0 = i === 0 ? vectors[0] : vectors[i-1];
          const p1 = vectors[i];
          const p2 = vectors[i+1];
          const p3 = i === vectors.length - 2 ? vectors[i+1] : vectors[i+2];
          const tension = 0.5;
          const xc1 = x(p1.x) + tension * (x(p2.x) - x(p0.x)) / 2;
          const yc1 = y(p1.y) + tension * (y(p2.y) - y(p0.y)) / 2;
          const xc2 = x(p2.x) - tension * (x(p3.x) - x(p1.x)) / 2;
          const yc2 = y(p2.y) - tension * (y(p3.y) - y(p1.y)) / 2;
          pathData += ` C ${xc1} ${yc1}, ${xc2} ${yc2}, ${x(p2.x)} ${y(p2.y)}`;
        }

        svg.innerHTML = '';
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#00ffaa');
        path.setAttribute('stroke-width', '2');
        svg.appendChild(path);
        document.querySelector('#chart .loader').style.display = 'none';
      }

      renderAudio() {
        const container = document.getElementById('audioContainer');
        container.innerHTML = '';
        const audio = document.createElement('audio');
        audio.controls = true;
        audio.src = this.audioUrl;
        container.appendChild(audio);
      }

      renderVideo() {
        const container = document.getElementById('videoContainer');
        container.innerHTML = '';
        const video = document.createElement('video');
        video.controls = true;
        video.src = this.videoUrl;
        container.appendChild(video);
      }
    }

    // ======================
    // INIT & UI BINDINGS
    // ======================
    const server = new Server();
    const client = new Client();

    // Link server to client
    server.onChunkReady = (chunk) => client.receiveChunk(chunk);
    server.onComplete = () => {
      document.getElementById('startStreamBtn').disabled = false;
    };

    // Progress helpers
    function setProgress(id, value) {
      document.getElementById(id).style.width = `${value * 100}%`;
    }

    // GRAPH
    document.getElementById('loadGraphBtn').addEventListener('click', async () => {
      try {
        await server.loadGraphData('./samplebtc.csv', (p) => setProgress('graphProgress', p));
        server.encodeGraphToVectors();
        document.getElementById('startStreamBtn').disabled = false;
      } catch (err) {
        server.log(`‚ùå ${err.message}`);
      }
    });

    document.getElementById('graphFile').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      try {
        await server.loadGraphData(file, (p) => setProgress('graphProgress', p));
        server.encodeGraphToVectors();
        document.getElementById('startStreamBtn').disabled = false;
      } catch (err) {
        server.log(`‚ùå ${err.message}`);
      }
    });

    // AUDIO
    document.getElementById('loadAudioBtn').addEventListener('click', async () => {
      const url = document.getElementById('audioUrl').value.trim();
      if (!url) return alert('Enter a URL');
      try {
        await server.loadAudioData(url, (p) => setProgress('audioProgress', p));
        document.getElementById('startStreamBtn').disabled = false;
      } catch (err) {
        server.log(`‚ùå ${err.message}`);
      }
    });

    // VIDEO
    document.getElementById('loadVideoBtn').addEventListener('click', async () => {
      const url = document.getElementById('videoUrl').value.trim();
      if (!url) return alert('Enter a URL');
      try {
        await server.loadVideoData(url, (p) => setProgress('videoProgress', p));
        document.getElementById('startStreamBtn').disabled = false;
      } catch (err) {
        server.log(`‚ùå ${err.message}`);
      }
    });

    // STREAM CONTROL
    document.getElementById('startStreamBtn').addEventListener('click', () => {
      server.prepareStream();
      server.startStreaming();
      document.getElementById('startStreamBtn').disabled = true;
    });

    document.getElementById('resetStreamBtn').addEventListener('click', () => {
      if (server.streamInterval) clearInterval(server.streamInterval);
      client.graphVectors = [];
      client.audioUrl = null;
      client.videoUrl = null;
      document.getElementById('svg').innerHTML = '';
      document.getElementById('audioContainer').innerHTML = 'Stream reset.';
      document.getElementById('videoContainer').innerHTML = 'Stream reset.';
      document.getElementById('chart .loader').style.display = 'block';
      server.log("üîÅ Stream reset by user.");
      document.getElementById('clientLog').textContent = "[Client Log] Reset. Awaiting new stream...";
    });
  </script>
</body>
</html>